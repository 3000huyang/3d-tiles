# 3DTILES_implicit_tiling

**Version 0.0.0**, December 1, 2020

## Contributors

* Sam Suhag, Cesium
* Sean Lilley, Cesium
* Peter Gagliardi, Cesium
* Erixen Cruz, Cesium

## Status

Draft

## Dependencies

Written against the 3D Tiles 1.0 specification.

## Contents

- [3DTILES_implicit_tiling](#3dtiles_implicit_tiling)
  - [Contributors](#contributors)
  - [Status](#status)
  - [Dependencies](#dependencies)
  - [Contents](#contents)
  - [Overview](#overview)
  - [Use Cases](#use-cases)
  - [Configuration](#configuration)
  - [Tiling Schemes](#tiling-schemes)
  - [Template URIs](#template-uris)
  - [Availability](#availability)
    - [Tile Availability](#tile-availability)
    - [Content Availability](#content-availability)
    - [Subtree Availability](#subtree-availability)
    - [Morton Order](#morton-order)
  - [Subtrees](#subtrees)
  - [Content](#content)
  - [Buffers and BufferViews](#buffers-and-bufferviews)
  - [Examples](#examples)

## Overview

This extension to 3D Tiles enables implicit tiling. 

OUTLINE:
- What is implicit tiling? - Simpler way of describing a tileset with a predictable structure without naming every tile.
- Why would you use this? - Instead of explicitly listing a large number of tiles, use a pattern to keep the tileset.json small.

## Use Cases

OUTLINE:
- new/faster traversal algorithms
  - skip LODs can jump straight to a given tile
  - raycasting
  - faster GIS queries
- better interoperability with existing GIS standards
  - CDB
  - S2
  - WMTS
  - TMS
- Enables procedural tilesets generated by a server

## Configuration

OUTLINE:
- required options: refine, geometric error, max depth
- subtree depth, bounding volume, tiling scheme (link to respective sections)
- example directory structure (not required)
  - tileset.json which uses this extension
  - buffers/level/x/y/buffer.bin
  - content/level/x/y/model.gltf
  - subtrees/level/x/y/subtree.json

## Tiling Schemes

OUTLINE:
- Quadtree vs octree
- bounding volumes are quartered/eighthed automatically
- cartesian cube or cartographic cube covering root tileset
- geometric error is halved
- refine (ADD/REPLACE) applies to every tile
- subtree branching factor
- diagram: subdivision of tile (maybe reuse some from the [old draft?](https://github.com/CesiumGS/3d-tiles/tree/3DTILES_implicit_tiling/extensions/3DTILES_implicit_tiling))

## Template URIs

OUTLINE:
- level, x, y, z are templated in
- relative to tileset
- availability buffers used to determine when a tile exists
- used to describe tile availability files, content availability files, and subtree jsons
- diagram: how a pattern corresponds to tiles

## Availability

While tiling schemes and template URIs describe the structural patterns the tileset must follow, **availability** describes what data actually exists in the tree. Availability serves two main purposes:

1. It provides an efficient method for checking for the presence of data.
2. Including this information prevents extraneous HTTP requests that would result in 404 errors.

This extension provides three types of availability data for different purposes:

* [Tile availability](#tile-availability) - information about whether a given tile exists in the tileset tree.
* [Content availability](#content-availability) - information about whether a given tile has content (since tiles can be empty)
* [Subtree availability](#subtree-availability) - for memory considerations, tilesets are split into [subtrees](#subtrees). 

All three use the same form of data storage. Avaiablity takes the form of a bit vector with one bit per entity in consideration. a 1 indicates an entity exists, while a 0 indicates that the entity does not exist. These bit vectors are packed in binary using a format described in the [Boolean Data section](https://github.com/CesiumGS/3d-tiles/blob/3d-tiles-next/specification/Metadata/0.0.0/README.md#boolean-data) of the Cesium 3D Metadata Specification. This bit vector is stored in a [buffer](#buffers-and-bufferviews) and referenced using a `bufferView` JSON property.

However, storing a bit for every node in a tree can add up. This is especially true when every entity exists (a bit vector with all 1s) or no entity exists (all 0s). To help reduce the cost in these two cases, specifying `constant: 1` or `constant: 0` can be used in place of the bit vector to save memory.

OUTLINE:
- bit vector (describe this like in Cesium 3D Metadata spec?)
- `constant` can be used to save memory
- 1 indicates something is available, 0 indicates unavailable
- meaning depends on type of availability buffers
  - tile availability: does the tile exist?
  - content availability: does the tile have content
  - subtree availability: preview of immediate children availability so traversals can short-circuit
- diagram: tile and content availability
- diagram: subtree availability

### Tile Availability

Tile availability describes what tiles exist at a specific position in space. Though template URIs can represent any possible `(level, x, y)` or `(level, x, y, z)` tile (depending on the tiling scheme), a tileset will typically need only a small subset of the possible tiles. Tile availability explicitly list which tiles are present.
This allows querying for tiles while keeping network requests to a minimum.

Tile availability is a bit vector with one bit per node in the [subtree](#subtrees).

Useful formulas for the tile availability buffer:

| Quantity | Formula | Description |
| -------- | ------- | ----------- |
| `lengthBits` | `N^subtreeLevels - 1` | Length of buffer is determined by subtree levels 
| `lengthBytes` | `ceil(lengthBits / 8)` | Bytes needed to store the buffer | 
| `parent.index` | `floor((child.index - 1) / N)` | Index of the parent in the bit vector | 
| `parent.indexOf(child)` | `(child.index - 1) % N` | Index of the child within the parent's `N` children |
| `parent.children[k].index` | `N * index + k + 1` | Find the bit of the `k-th` child of a node |
| `index` | `N^level - 1 + mortonIndex` | Find the index of a node from `(level, mortonIndex)`
| `level` | `floor(log2(index + 1))` | Find the level of a node relative to the subtree |
| `globalLevel` | `level + subtreeRoot.globalLevel` | Find the level of a node relative to the entire tileset | 
| `startOfLevel` | `N^level - 1` | first index at a particular level (relative to the subtree root) |
| `mortonIndex` | `index - startOfLevel` | Convert from bit index to Morton index, relative to the root of the subtree |
| `globalMortonIndex` | `concat(subtreeRoot.globalMortonIndex, mortonIndex)` | Get the Morton index relative to the root of the tileset |


### Content Availability

### Subtree Availability

| Quantity | Formula | Description |
| -------- | ------- | ----------- |
| `lengthBits` | `N^subtreeLevels` | Length of the buffer by subtree levels |
| `lengthBytes` | `ceil(lengthBits / 8)` | Bytes needed to store the buffer |
| `subtree.globalLevel` | `subtreeRoot.global + subtreeLevels` | Level of the subtrees relative to the tileset root |
| `leaf.children[k].index` | `N * leaf.mortonIndex + k` | index of the `k-th` subtree |
| `leaf.indexOf(subtree)` | `subtreeRoot.mortonIndex % N` | Index of the subtree within the parent leaf's `N` children |
| `leaf.mortonIndex` | `floor(subtreeRoot.mortonIndex / N)` | Morton index of the parent leaf |

TODO: be clearer about conventions. which subtree am I referring to? it's a little unclear if I'm referring to the current subtree or one of the child subtrees.

### Morton Order

| Quantity | Formula | Description |
| -------- | ------- | ----------- |
| `N` | 4 or 8 | N is 4 for quadtrees, 8 for octrees |
| `bits` | `log2(N)` | Quadtree address are a multiple of 2 bits, Octrees use a multiple of 3 bits | 
| `mortonIndex` | `interleave(z, y, x)` or `interleave(y, x)` | The morton index is computed by interleaving bits. see below. |
| `length(mortonIndex)` | `level * bits` | length of morton index in bits
| `parent.mortonIndex` | `child.mortonIndex >> bits` | The parent morton index is a prefix of the child |
| `child[k].mortonIndex` | `(parent.mortonIndex << bits) + k` | Morton index of a node's `k-th` child in Morton order |
| `parent.indexOf(child)` | `child.mortonIndex % N` or `child.mortonIndex & (N - 1)` | Index of the child within the parent's `N` children |

```
N = 4 for quadtrees, 8 for octrees
lgN = log2(N) = 2 for quadtrees, 3 for octrees

level = level of tile in quadtree or octree
x, y, z = coordinates of tile at the deepest level. z is only used for octrees.

mortonIndex = interleave(z, y, x) or interleave(y, x) for quadtrees
length(mortonIndex) = level * lgN // measured in bits

parent.mortonIndex = child.mortonIndex >> lgN
child[k].mortonIndex = parent.mortonIndex << lgN + k
parent.indexOf(child) = child.mortonIndex % N = child.mortonIndex & (N - 1)
```

OUTLINE:
- better locality of reference
- takes into account hierarchy (simple to find parent index)
- see what can be reused from old draft

## Subtrees

OUTLINE:
- fixed depth subtree chunk of root tree
- json file points to buffers (or constants) with tile, child subtree, content availabilities
- children availability used for traversal for retrieval of tile
- subtrees contain mutually exclusive tiles, and completely cover the entire tree
- include formulas from `example/subtree.json`
- diagram: how subtrees fit together to make a tree

## Content

OUTLINE:
- Same concept as in the main 3D Tiles spec
- One content per tile
- mimeType is required to identify the type of content. This is not in the core spec

## Buffers and BufferViews

OUTLINE:
- describe
- refer to Cesium Metadata spec
- describe these again so they're standalone?
- Any chance we can reuse material?

## Examples

OUTLINE:
- make example more concrete
- link to it here